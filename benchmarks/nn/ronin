#!/usr/bin/env python

import sys
import pathlib
from ronin.cli import cli
from ronin.gcc import GccCompile, GccLink, GccExecutor
from ronin.executors import ExecutorWithArguments
from ronin.contexts import new_context
from ronin.phases import Phase
from ronin.projects import Project
from ronin.utils.paths import glob
from ronin.utils.platform import which

if sys.version_info.major < 3:
    print("Python 3 required")
    sys.exit(1)

ENZYME_DYLIB = (
    pathlib.Path.home()
    / "Research"
    / "Enzyme"
    / "enzyme"
    / "build"
    / "Enzyme"
    / "LLVMEnzyme-12.dylib"
)

LAGRAD_LLVM_DYLIB = (
    pathlib.Path.home()
    / "Research"
    / "profile-pass"
    / "build"
    / "profiler"
    / "libProfilerPass.dylib"
)

OPENBLAS_INCLUDE = pathlib.Path.home() / ".local" / "OpenBLAS" / "include"

MLIR_RUNNER_UTILS = (
    pathlib.Path.home() / ".local" / "lib" / "libmlir_runner_utils.dylib"
)


class LAGradOptFlags:
    preprocess = [
        "-take-grads",
        "-canonicalize",
        "-inline",
        "-linalg-canonicalize",
        "-standalone-dce",
        "-convert-elementwise-to-linalg",
        "-convert-linalg-triangular-to-loops",
        "-canonicalize",
    ]
    bufferize = [
        "-tensor-constant-bufferize",
        "-tensor-bufferize",
        "-standalone-bufferize",
        "-linalg-bufferize",
        "-scf-bufferize",
        "-func-bufferize",
        "-finalizing-bufferize",
        "-buffer-hoisting",
        "-buffer-loop-hoisting",
        "-standalone-loop-hoisting",
        "-promote-buffers-to-stack",
        "-buffer-deallocation",
        "-canonicalize",
    ]
    lower_to_llvm = [
        # "-convert-linalg-to-library",
        "-convert-linalg-to-loops",
        # "-convert-linalg-to-affine-loops",
        # "-affine-loop-unroll",
        "-lower-affine",
        "-convert-scf-to-std",
        "-convert-memref-to-llvm",
        "-convert-math-to-llvm",
        "-convert-math-to-libm",
        "-convert-std-to-llvm",
        "-reconcile-unrealized-casts",
        "-llvm-legalize-for-export",
    ]


PRE_ENZYME_OPT = [
    "-O2",
    "-fno-vectorize",
    "-fno-slp-vectorize",
    "-ffast-math",
    "-fno-unroll-loops",
]


class ClangEmitLLVM(GccExecutor):
    def __init__(self, command: str = None, ccache=True, platform=None):
        super(ClangEmitLLVM, self).__init__(command, ccache, platform)
        self.command = lambda ctx: which(
            ctx.fallback(command, "gcc.gcc_command", "clang-12")
        )
        self.add_argument_unfiltered("$in")
        self.add_argument("-S", "-emit-llvm")

        self.command_types = ["clang_compile"]
        self.output_type = "object"
        self.output_extension = "ll"
        self.create_makefile_ignore_system()
        self.add_argument_unfiltered("-MF", "$out.d")  # set_makefile_path
        self._deps_file = "$out.d"
        self._deps_type = "gcc"


class ClangCompileLLVM(GccExecutor):
    def __init__(self, command: str = None, ccache=True, platform=None):
        super(ClangCompileLLVM, self).__init__(command, ccache, platform)
        self.command = lambda ctx: which(
            ctx.fallback(command, "gcc.gcc_command", "clang-12")
        )
        self.add_argument_unfiltered("$in")

        self.command_types = ["clang_compile"]
        self.output_type = "object"
        self.output_extension = "o"
        self.compile_only()

    def ignore_override_module(self):
        self.add_argument("-Wno-override-module")
        return self


class LAGradOptExecutor(ExecutorWithArguments):
    def __init__(self, command: str = None, default_args=True):
        super(LAGradOptExecutor, self).__init__()
        self.command = lambda ctx: which(
            ctx.fallback(command, "lagrad.opt_command", "lagrad-opt")
        )
        self.add_argument_unfiltered("$in")
        self.add_argument_unfiltered("-o", "$out")
        self.output_type = "object"
        self.output_extension = "mlir"
        if default_args:
            self.add_argument(*LAGradOptFlags.preprocess)
            self.add_argument(*LAGradOptFlags.bufferize)
            self.add_argument(*LAGradOptFlags.lower_to_llvm)


class MLIRTranslateExecutor(ExecutorWithArguments):
    def __init__(self, command: str = None):
        super(MLIRTranslateExecutor, self).__init__()
        self.command = lambda ctx: which(
            ctx.fallback(command, "lagrad.translate_command", "mlir-translate")
        )
        self.add_argument_unfiltered("$in")
        self.add_argument_unfiltered("-o", "$out")
        self.output_type = "object"
        self.output_extension = "ll"
        self.add_argument("-mlir-to-llvmir")


class OptExecutor(ExecutorWithArguments):
    def __init__(self, command: str = None, asm=False):
        super(OptExecutor, self).__init__()
        self.command = lambda ctx: which(
            ctx.fallback(command, "llvm.opt_command", "opt")
        )
        self.add_argument_unfiltered("$in")
        self.add_argument_unfiltered("-o", "$out")
        self.output_type = "object"
        self.output_extension = "ll"
        if asm:
            self.add_argument("-S")

    def run_enzyme(self):
        self.add_argument("-load", ENZYME_DYLIB, "-enzyme")
        return self

    def run_fast_math(self):
        self.add_argument(
            "-enable-new-pm=0", "-load", LAGRAD_LLVM_DYLIB, "-llfast-math"
        )
        return self


def compile_enzyme(project: Project, inputs: list[str]) -> Phase:
    emit_llvm = ClangEmitLLVM()
    emit_llvm.add_argument(*PRE_ENZYME_OPT)
    preenzyme = Phase(
        project=project,
        name="Pre-Enzyme C to LLVM IR",
        inputs=inputs,
        executor=emit_llvm,
    )

    run_enzyme = OptExecutor("opt-12").run_enzyme()
    run_enzyme.add_argument("-O2")
    postenzyme = Phase(
        project=project,
        name="Enzyme AD",
        inputs_from=[preenzyme],
        executor=run_enzyme,
    )

    return Phase(
        project=project,
        name="Post-Enzyme Objects",
        inputs_from=[postenzyme],
        executor=ClangCompileLLVM(),
    )


def compile_lagrad(project: Project, inputs: list[str], fast_math=True) -> Phase:
    lagrad_llvm_dialect = Phase(
        project=project,
        name="Lower to LLVM Dialect",
        inputs=inputs,
        executor=LAGradOptExecutor(),
    )
    llvm_ir = Phase(
        project=project,
        name="LAGrad Translate to LLVM IR",
        inputs_from=[lagrad_llvm_dialect],
        executor=MLIRTranslateExecutor(),
    )
    if fast_math:
        llvm_ir = Phase(
            project=project,
            name="LAGrad fast-math flags",
            inputs_from=[llvm_ir],
            executor=OptExecutor().run_fast_math(),
        )
    lagrad_clang = ClangCompileLLVM()
    lagrad_clang.optimize(3)
    lagrad_clang.ignore_override_module()
    return Phase(
        project=project,
        name="LAGrad objects",
        inputs_from=[llvm_ir],
        executor=lagrad_clang,
    )


with new_context() as ctx:
    project = Project("Multi-layer Perceptron Benchmark")
    enzyme_phase = compile_enzyme(project, ["enzyme_nn.c"])
    lagrad_phase = compile_lagrad(project, ["nn.mlir"])

    compile_executor = GccCompile("clang-12")
    compile_executor.optimize(3)
    comp = Phase(
        project=project,
        name="Compile C",
        inputs=["main.c", "read_data.c"],
        executor=compile_executor,
    )

    linker = GccLink("clang-12")
    linker.add_argument("-rpath", pathlib.Path.home() / ".local" / "lib")
    linker.optimize(3)
    Phase(
        project=project,
        name="Link",
        inputs=[str(MLIR_RUNNER_UTILS)],
        inputs_from=[comp, enzyme_phase, lagrad_phase],
        executor=linker,
        output="neuralnet.out",
    )

    cli(project)
